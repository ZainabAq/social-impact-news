---
title: "main-file"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Remains the same for everyone
```{r, message=FALSE}
library(tidyverse)
library(readr)
# change this according to your
data_10000 <- read_csv("Raw data_10000 articles_Jul-Dec 2017.csv")
```


# Sections for everyone

# Minji

```{r}
##removing na's and creating the existing metric
Sint_PV <- data_10000%>%
  mutate(metric = `Social interactions`/Views)%>%
  arrange(desc(metric))%>%
  na.omit(`Engaged minutes`)%>%
  na.omit(`Social interactions`)

##creating vectors 
engaged_min <- Sint_PV$`Engaged minutes`
metric <-Sint_PV$metric
soc_int <- Sint_PV$`Social interactions`
pv <- Sint_PV$`Sort (Views)`
rv <- Sint_PV$`Returning vis.`

##looking at the correlations
cor(engaged_min, soc_int)
cor(engaged_min, metric)
cor(engaged_min, pv)
cor(engaged_min, rv)
cor(rv, metric)
```

[Log-normal distribution](https://en.wikipedia.org/wiki/Log-normal_distribution) seems reasonable? 

```{r}
ggplot(Sint_PV, aes(x = log(metric))) + 
  geom_density()
```

Use MLE to find best-fit parameters? 

```{r}
##fitting it into a pareto distribution
library(EnvStats)
PVdf <- data.frame(dpareto(pv,1,1))
RVdf <- data.frame(dpareto(rv,1,1))
Sintdf <- data.frame(dpareto(soc_int,1,1))
engmin<-data.frame(dpareto(engaged_min, 1, 1))

##Calculating the MLE for pareto distribution. 
pareto.MLE <- function(X)
{
   n <- length(X)
   m <- min(X)
   a <- n/sum(log(X)-log(m))
   return( c(m,a) ) 
}

##output of the pareto function.
library(VGAM)
set.seed(1)
pareto.MLE(PVdf)
pareto.MLE(RVdf)
pareto.MLE(engmin)
pareto.MLE(Sintdf)


##mean of Page View
(7.407267e-05*1.516749e-13)/(7.407267e-05-1)
##sd of Page View
(1.516749e-13^2*7.407267e-05)/((7.407267e-05-1)^2*(7.407267e-05-1))

##mean of Returing Views 
(9.826825e-05*4.418560e-12)/(9.826825e-05-1)
##sd of Returing Views
(4.418560e-12^2*9.826825e-05)/((9.826825e-05-1)^2*(9.826825e-05-1))

##mean of engaged min
(7.573356e-05*3.401360e-13)/(7.573356e-05-1)
##sd of engaged min
(3.401360e-13^2*7.573356e-05)/((7.573356e-05-1)^2*(7.573356e-05-1))

##mean of Socail interaction
(4.628359e-05*3.827637e-13)/(4.628359e-05-1)
##sd of Socail interaction 
(3.827637e-13*4.628359e-05)/((4.628359e-05-1)^2*(4.628359e-05-1))



##looking at the top engaged mins
Eng_sort <-data_10000%>%
  arrange(desc(`Engaged minutes`))


```


# Erina

```{r}

```


# Julianna 

```{r}
#Which articles have the highest engaged mins?
data_10000 %>%
  arrange(`Engaged minutes`) %>%
  select(Title)

#Which articles have the highest social interactions?
data_10000 %>%
  arrange(`Social interactions`) %>%
  select(Title)

#Scatterplot Matrix
pairs(~`Social interactions`+`Engaged minutes`+`Views`+`Social refs`+`Returning vis.`, data=data_10000, main="Simple Scatterplot Matrix")



####Basic stats------------------------------------------

#huff_metric
  #Creating huff metric
test <- data_10000 %>%
  mutate(`huff_metric` = `Social interactions`/ `Views`, log_huff_metric = log(huff_metric)) %>%
  arrange(desc(huff_metric))

#Looking at titles of highest huff metric data
highest_huff <- test %>%
  select(Title, huff_metric, Section)

highest_huff_100 <- highest_huff[1:100,]

#cor matrix
selected_data <- test %>%
  select(`Social interactions`,`Engaged minutes`,`Views`,`Social refs`,`Returning vis.`, `huff_metric`)

library(Hmisc)
res2 <- rcorr(as.matrix(selected_data))
res2

#How many "impact" articles
mosaic::tally(highest_huff_100$Section)

mosaic::tally(test$Section)

  #now the stats
mosaic::favstats(test$huff_metric)

ggplot(data = test, aes(`huff_metric`)) + geom_histogram()

ggplot(data = test, aes(log(`huff_metric`))) + geom_histogram()
  #testing normality
qqnorm(test$log_huff_metric)
qqline(test$log_huff_metric, col = "red")


#creating log variables
test <- test %>%
  mutate(log_social_interactions = log(`Social interactions`), log_engaged_minutes = log(`Engaged minutes`), log_views = log(`Views`))

#Social interactions
mosaic::favstats(test$`Social interactions`)

ggplot(data = test, aes(`Social interactions`)) + geom_histogram()

ggplot(test, aes(`Social interactions`)) + 
    geom_histogram(aes(y=..density..),fill="gray40") +
    geom_density(alpha=.2, color = "red")

ggplot(data = test, aes(log(`Social interactions`))) + geom_histogram()

ggplot(test, aes(log(`Social interactions`))) + 
    geom_histogram(aes(y=..density..),fill="gray40") +
    geom_density(alpha=.2, color = "red")

  #Testing normality
qqnorm(test$log_social_interactions)
qqline(test$log_social_interactions, col = "red")

  #engaged vs social interactions
ggplot(data = test, aes(x = `Social interactions`, y = `Engaged minutes`)) + geom_point() + 
  geom_smooth()

ggplot(data = test, aes(x = log(`Social interactions`), y = log(`Engaged minutes`))) + geom_point() + 
  geom_smooth()

#Engaged Minutes
mosaic::favstats(test$`Engaged minutes`)

ggplot(data = test, aes(`Engaged minutes`)) + geom_histogram()

ggplot(test, aes(`Engaged minutes`)) + 
    geom_histogram(aes(y=..density..),fill="gray40") +
    geom_density(alpha=.2, color = "red")

ggplot(data = test, aes(log(`Engaged minutes`))) + geom_histogram()

ggplot(test, aes(log(`Engaged minutes`))) + 
    geom_histogram(aes(y=..density..),fill="gray40") +
    geom_density(alpha=.2, color = "red")

  #Testing normality
qqnorm(test$log_engaged_minutes)
qqline(test$log_engaged_minutes, col = "red")

#Views
mosaic::favstats(test$Views)

ggplot(data = test, aes(`Views`)) + geom_histogram()

ggplot(data = test, aes(log(`Views`))) + geom_histogram()

  #Testing normality
qqnorm(test$Views)
qqline(test$Views, col = "red")

qqnorm(test$log_views)
qqline(test$log_views, col = "red")

##MODELS--------------------------------------------------

#Finding predictors from backward and stepwise regression
fullmodel <- lm(`huff_metric`~`Views`+`Engaged minutes`+`Returning vis.`+`New vis.`+`Social refs`+`Social interactions`+`Avg. minutes new vis.`+`Avg. minutes ret. vis.`+`Visitors`+`Avg. views new vis.`+`Avg. views ret. vis.`, data = test)
# backward
fullMSE <- (summary(fullmodel)$sigma)^2
step(fullmodel, data = test, scale = fullMSE, direction = "backward")

test<-na.omit(test)
#stepwise
nullmodel <- lm(`huff_metric` ~ 1, data = test)
step(nullmodel, scope = list(upper = fullmodel),
scale = fullMSE, direction = "both")

#Stepwise gave me this model:
mod_huff <- lm(formula = huff_metric ~ `Social interactions` + `Avg. minutes ret. vis.` + 
    `Returning vis.` + `Engaged minutes` + `New vis.` + `Social refs` + 
    Views + `Avg. views new vis.`, data = test)

summary(mod_huff)

plot(mod_huff)

  #cor matrix for the model
selected_data_mod_step <- test %>%
  select(`Social interactions`, `Avg. minutes ret. vis.`, 
    `Returning vis.`, `Engaged minutes`, `New vis.`, `Social refs`, 
    Views, `Avg. views new vis.`)

  #Nothing abnormally high except (engaged min and returning visitors), (new vis and views), (Social refs and views)
res2 <- rcorr(as.matrix(selected_data_mod_step))
res2

  #checking VIF
library(car)
vif(mod_huff)
#There are big issues of multicollinearity in this model

##How about best subset approach?
library(leaps)

allsubset<-regsubsets(`huff_metric`~`Views`+`Engaged minutes`+`Returning vis.`+`New vis.`+`Social refs`+`Social interactions`+`Avg. minutes new vis.`+`Avg. minutes ret. vis.`+`Visitors`+`Avg. views new vis.`+`Avg. views ret. vis.`, data = test)
options(digits=3)

summary(allsubset)$adjr2
plot(allsubset,scale="adjr2")

summary(allsubset)$cp
plot(allsubset,scale="Cp")

#Gives us THIS model:
mod_all <- lm(`huff_metric`~`Views`+`Engaged minutes`+`Returning vis.`+`New vis.`+`Social refs`+`Social interactions`+`Avg. minutes ret. vis.`+ `Avg. views new vis.`, data = test)

summary(mod_all)

  #Checking for multicollinearity again
selected_data_mod_best <- test %>%
  select(`Views`,`Engaged minutes`,`Returning vis.`,`New vis.`,`Social refs`,`Social interactions`,`Avg. minutes ret. vis.`,`Avg. views new vis.`)

res2 <- rcorr(as.matrix(selected_data_mod_best))
res2

car::vif(mod_all)
  #Way better with multicollinearity!

#checking section
mod_all_sec1 <- lm(`huff_metric`~`Views`+`Engaged minutes`+`Returning vis.`+`New vis.`+`Social refs`+`Social interactions`+`Avg. minutes ret. vis.`+ `Avg. views new vis.`+Section, data = test)

summary(mod_all_sec1)

test_comb_section <- test %>%
  mutate(black_voices = ifelse(Section == "Black Voices", "yes", "no"))
#what happens when I add that to the model?
mod_all_sec <- lm(`huff_metric`~`Views`+`Engaged minutes`+`Returning vis.`+`New vis.`+`Social refs`+`Social interactions`+`Avg. minutes ret. vis.`+ `Avg. views new vis.`+black_voices, data = test_comb_section)

#This should be something we consider. Do sections fit into theoretical definition of social impact?
```


# Zainab

```{r}
require(mosaic)
favstats(data_10000$Views)

c <- ggplot(data_10000, aes(Views))
c+geom_histogram()

fav_stats(data_10000$`Engaged minutes`)
d <- ggplot(data_10000, aes(`Engaged minutes`))
d+geom_histogram()

ggplot(data_10000, aes_string(x = "`Social refs`", y = "`Engaged minutes`")) +
  theme_bw() +
  geom_jitter()

ggplot(data_10000, aes_string(x = "`Returning vis.`", y = "`Engaged minutes`")) +
  theme_bw() +
  geom_jitter()

ggplot(data_10000, aes_string(x = "Visitors", y = "`Engaged minutes`")) +
  theme_bw() +
  geom_jitter()

data_10000 = data_10000 %>%
  mutate(logEngMins = log(`Engaged minutes`))

data_10000 = data_10000 %>%
  mutate(logRetVisitors = log(`Returning vis.`))

ggplot(data_10000, aes_string(x = "logRetVisitors", y = "logEngMins")) +
  theme_bw() +
  geom_jitter()

c <- ggplot(data_10000, aes(logRetVisitors))
c+geom_histogram()

f <- ggplot(data_10000, aes(logEngMins))
f+geom_histogram()

ggplot(data_10000, aes_string(x = "`Social refs`", y = "Visitors")) +
  theme_bw() +
  geom_jitter()

ggplot(data_10000, aes_string(x = "`Social refs`", y = "`New vis.`")) +
  theme_bw() +
  geom_jitter()


data_10000 %>%
  select(c(`Returning vis.`,`Social refs`, `Engaged minutes`, `Avg. views new vis.`, Views, Visitors, `New vis.`))%>%
  cor()
```


