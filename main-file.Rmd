---
title: "main-file"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Remains the same for everyone
```{r}
library(readr)
# change this according to your
data_10000 <- read_csv("Raw data_10000 articles_Jul-Dec 2017.csv")
```


# Sections for everyone

# Minji

```{r}
library(dplyr)
library(mosaic)
library(randomForest)
library(ParetoPosStable)
library(tree)
library(gbm)
library(adabag)
library(EnvStats)
library(caret)

##removing na's and creating the existing metric
Sint_PV <- data_10000%>%
  mutate(metric = `Social interactions`/Views)%>%
  arrange(desc(metric))%>%
  na.omit(`Engaged minutes`)%>%
  na.omit(`Social interactions`)

##creating vectors 
engaged_min <- Sint_PV$`Engaged minutes`
metric <-Sint_PV$metric
soc_int <- Sint_PV$`Social interactions`
pv <-as.data.frame(Sint_PV$`Views`) 
V <-Sint_PV$`Views`
rv <- Sint_PV$`Returning vis.`


##Pareto Distribution
pareto.fit(V, estim.method = "MLE")

ggplot(pv, aes(log(V))) + geom_histogram(aes(y=..density..), bins = 100 ) + stat_function(fun = dnorm, args = list(11.68749, 1.013802), color = "red")

p <- ggplot(pv, aes(V)) + geom_histogram(aes(y=..density..), bins = 100) 
p+ stat_function(fun = dpareto, args = list(7795, 0.4751), color = "red")

###################################################################################################

merged_200 <- read_csv("merged_200.csv")
minji_50 <- merged_200[101:150,]
write.table(minji_50, file="minji_50.csv",sep=",",row.names=F)
minji_50_impact <- read_csv("minji_50_impact.csv")
rated_200 <- read_csv("rated_200.csv")
tally(~Section, data_10000)
politics <- data_10000 %>%
  filter(Section == "Politics")
write.table(politics, file="politics.csv", sep =",", row.names=F)
###################################################################################################

rated_200 <- rated_200 %>%
  mutate(Impact1 = ifelse(Impact == 9, 1, ifelse(Impact == 1, 1, 0)))%>%
  select(-Impact)


##Cleaning Data before Modeling 
spaceless <- function(x) {colnames(x) <- gsub(" ", "_", colnames(x));x}
hless <- function(x) {colnames(x) <- gsub("-", "_", colnames(x));x}
clean_200 <- spaceless(rated_200)
clean_200 <- hless(clean_200)
clean_200 <- na.omit(clean_200)

##Classification Tree of the whole dataset
tree <- tree(as.factor(Impact1) ~. -Tags -`Sort_(Views)` -text -keywords -summary -URL -Title -Authors -Section -Publish_date -X1 , clean_200 )
head(clean_200)
summary(tree)
plot(tree)
text(tree, pretty=0)

#Dividing the data into testing and training
set.seed(5)
clean_train <- clean_200 %>%
  sample_frac(0.5)

clean_test <- clean_200%>%
  setdiff(clean_train)

##Random Forest model 
set.seed(5)
m0 <- randomForest(as.factor(Impact1) ~. -Tags -`Sort_(Views)` -text -keywords -summary -URL -Title -Authors -Section -Publish_date -X1, data=clean_train, importance = TRUE, ntree=2000, mtry=5)
varImpPlot(m0)

m0_estimates = predict(m0, newdata = clean_test, n.trees = 2000) 

table(m0_estimates, clean_test$Impact1)

(17+23)/64 ##60.9% correct predictions.


##Random Forest model with Conditional inference (uses statistical test rather than purity)
set.seed(5)
m1 <- randomForest(as.factor(Impact1) ~. -Tags -`Sort_(Views)` -text -keywords -summary -URL -Title -Authors -Section -Publish_date -X1, data=clean_train, controls=cforest_unbiased(ntree=2000, mtry=5))
varImpPlot(m1)

m1_estimates = predict(m1, newdata = clean_test, OOB=TRUE, type = "response") 
table(m1_estimates, clean_test$Impact1)
(15+22)/64 ##62.5 correct predictions

##Classication tree
set.seed(5)
m2 <- tree(as.factor(Impact1) ~ . -Tags -`Sort_(Views)` -text -keywords -summary -URL -Title -Authors -Section -Publish_date -X1, data=clean_train)
summary(m2)
plot(m2)
text(m2, pretty = 0)
m2_estimates = predict(m2, clean_test, type = "class")
table(m2_estimates, clean_test$Impact1)
(22+19)/64 ##64.1% correct predictions 

##Pruned tree with CV 
set.seed(5)
m3 <- cv.tree(m2, FUN = prune.misclass)
plot(m3$size, m3$dev, type = "b")
m4 <- prune.misclass(m2, best = 5)
plot(m4)
text(m4, pretty = 0)
m4_estimates = predict(m4, clean_test, type = "class")
table(m4_estimates, clean_test$Impact1)
(22+21)/64 ##67.2% correct predictions

##Boosting with Classification 
clean_boost <- clean_200 %>%
  select( -Tags, -`Sort_(Views)`, -text, -keywords, -summary, -URL, -Title, -Authors, -Section, -Publish_date, -X1)

m5<- gbm(Impact1 ~., data = clean_boost, distribution = "bernoulli", n.trees = 500, cv.folds = 5, verbose = F)
best.iter = gbm.perf(m5, method = "cv")

clean_boost2 <- clean_boost %>%
  mutate(Impact = ifelse(Impact1 == 1, "Y", "N" )) %>%
  select(-Impact1)

set.seed(5)
fitControl = trainControl(method="cv", summaryFunction =  twoClassSummary, classProbs = TRUE, number = 5, returnResamp = "all")
m6 <- train(Impact~., data=clean_boost2, method="gbm", trControl=fitControl, tuneGrid=data.frame(.n.trees=best.iter, .shrinkage=0.01, .interaction.depth=1, .n.minobsinnode=1), verbose=FALSE,  metric = "ROC", distribution = "bernoulli")
m6
confusionMatrix(m6)
m6_estimates = predict(m6, clean_boost2)
postResample(m6_estimates, as.factor(clean_boost2$Impact))
```


# Erina

```{r}

```


# Julianna 

```{r}
data_10000 %>%
  arrange(`Engaged minutes`) %>%
  select(Title)

ggplot(data = data_10000, aes(log(`Social interactions`))) + geom_histogram()

ggplot(data = data_10000, aes(log(`Views`))) + geom_histogram()

ggplot(data = data_10000, aes(`Views`)) + geom_histogram()

test <- data_10000 %>%
  mutate(`huff_metric` = `Social interactions`/ `Views`, log_huff_metric = log(huff_metric)) %>%
  arrange(desc(huff_metric))

fav_stats(test$log_huff_metric)

ggplot(data = test, aes(log(`huff_metric`))) + geom_histogram()

ggplot(data = test, aes(x = log(`Social interactions`), y = log(`Engaged minutes`))) + geom_point() + 
  geom_smooth()

test <- test %>%
  mutate(log_social_interactions = log(`Social interactions`), log_engaged_minutes = log(`Engaged minutes`), log_views = log(`Views`))

cor(test$log_social_interactions, test$log_engaged_minutes, use = "complete.obs")

qqnorm(test$log_huff_metric)
qqline(test$log_huff_metric, col = "red")

qqnorm(test$log_social_interactions)
qqline(test$log_social_interactions, col = "red")

qqnorm(test$Views)
qqline(test$Views, col = "red")

qqnorm(test$log_views)
qqline(test$log_views, col = "red")
```


# Zainab

```{r}
require(mosaic)
favstats(data_10000$Views)

c <- ggplot(data_10000, aes(Views))
c+geom_histogram()

fav_stats(data_10000$`Engaged minutes`)
d <- ggplot(data_10000, aes(`Engaged minutes`))
d+geom_histogram()

ggplot(data_10000, aes_string(x = "`Social refs`", y = "`Engaged minutes`")) +
  theme_bw() +
  geom_jitter()

ggplot(data_10000, aes_string(x = "`Returning vis.`", y = "`Engaged minutes`")) +
  theme_bw() +
  geom_jitter()

ggplot(data_10000, aes_string(x = "Visitors", y = "`Engaged minutes`")) +
  theme_bw() +
  geom_jitter()

data_10000 = data_10000 %>%
  mutate(logEngMins = log(`Engaged minutes`))

data_10000 = data_10000 %>%
  mutate(logRetVisitors = log(`Returning vis.`))

ggplot(data_10000, aes_string(x = "logRetVisitors", y = "logEngMins")) +
  theme_bw() +
  geom_jitter()

c <- ggplot(data_10000, aes(logRetVisitors))
c+geom_histogram()

f <- ggplot(data_10000, aes(logEngMins))
f+geom_histogram()

ggplot(data_10000, aes_string(x = "`Social refs`", y = "Visitors")) +
  theme_bw() +
  geom_jitter()

ggplot(data_10000, aes_string(x = "`Social refs`", y = "`New vis.`")) +
  theme_bw() +
  geom_jitter()


data_10000 %>%
  select(c(`Returning vis.`,`Social refs`, `Engaged minutes`, `Avg. views new vis.`, Views, Visitors, `New vis.`))%>%
  cor()
```


